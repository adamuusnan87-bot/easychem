// Advanced Chemistry Engine JavaScript

class ZamaniChem {
    constructor() {
        this.init();
    }
    
    init() {
        this.setupEventListeners();
        this.detectDevice();
        this.loadSavedData();
        this.setupServiceWorker();
    }
    
    detectDevice() {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isTablet = /iPad|Android|Tablet/i.test(navigator.userAgent);
        
        document.body.classList.toggle('mobile', isMobile);
        document.body.classList.toggle('tablet', isTablet);
        document.body.classList.toggle('desktop', !isMobile && !isTablet);
        
        // Add touch detection
        if ('ontouchstart' in window || navigator.maxTouchPoints) {
            document.body.classList.add('touch-device');
        }
    }
    
    setupEventListeners() {
        // Auto-format chemical equations
        document.querySelectorAll('input[name="equation"]').forEach(input => {
            input.addEventListener('input', this.formatChemicalEquation.bind(this));
        });
        
        // Periodic table integration
        this.setupPeriodicTable();
        
        // Save reaction functionality
        document.getElementById('saveReactionBtn')?.addEventListener('click', this.saveReaction.bind(this));
        
        // Offline detection
        window.addEventListener('online', this.updateOnlineStatus.bind(this));
        window.addEventListener('offline', this.updateOnlineStatus.bind(this));
        
        // Beforeunload for unsaved changes
        window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
    }
    
    formatChemicalEquation(e) {
        const input = e.target;
        let value = input.value;
        
        // Convert numbers to subscripts
        value = value.replace(/2/g, '₂')
                     .replace(/3/g, '₃')
                     .replace(/4/g, '₄')
                     .replace(/5/g, '₅')
                     .replace(/6/g, '₆')
                     .replace(/7/g, '₇')
                     .replace(/8/g, '₈')
                     .replace(/9/g, '₉')
                     .replace(/0/g, '₀')
                     .replace(/1/g, '₁');
        
        // Convert arrow symbols
        value = value.replace(/->/g, '→')
                     .replace(/=/g, '→');
        
        // Update input with formatted value (store original separately)
        input.dataset.originalValue = e.target.value;
        
        // Only update display if cursor isn't in middle of typing
        if (!input.matches(':focus') || e.inputType === 'insertText') {
            setTimeout(() => {
                input.value = value;
            }, 0);
        }
    }
    
    setupPeriodicTable() {
        // Create periodic table modal
        const modal = document.createElement('div');
        modal.className = 'periodic-table-modal';
        modal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <h3><i class="fas fa-table"></i> Periodic Table</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div class="modal-body" id="periodicTableGrid">
                    <!-- Generated by JS -->
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Fetch periodic table data
        this.loadPeriodicTable();
    }
    
    async loadPeriodicTable() {
        try {
            const response = await fetch('/elements');
            const elements = await response.json();
            this.renderPeriodicTable(elements);
        } catch (error) {
            console.error('Failed to load periodic table:', error);
        }
    }
    
    renderPeriodicTable(elements) {
        const grid = document.getElementById('periodicTableGrid');
        if (!grid) return;
        
        // Group by period
        const periods = {};
        elements.forEach(element => {
            if (!periods[element.period]) periods[element.period] = [];
            periods[element.period].push(element);
        });
        
        // Create grid
        let html = '';
        for (let period = 1; period <= 7; period++) {
            const periodElements = periods[period] || [];
            html += `<div class="period-row" data-period="${period}">`;
            
            for (let group = 1; group <= 18; group++) {
                const element = periodElements.find(e => e.group === group);
                if (element) {
                    html += `
                        <div class="element" 
                             data-symbol="${element.symbol}"
                             data-name="${element.name}"
                             data-mass="${element.atomic_mass}"
                             data-number="${element.atomic_number}"
                             style="grid-column: ${group}">
                            <div class="element-number">${element.atomic_number}</div>
                            <div class="element-symbol">${element.symbol}</div>
                            <div class="element-name">${element.name}</div>
                            <div class="element-mass">${element.atomic_mass.toFixed(2)}</div>
                        </div>
                    `;
                }
            }
            
            html += '</div>';
        }
        
        grid.innerHTML = html;
        
        // Add click handlers
        document.querySelectorAll('.element').forEach(el => {
            el.addEventListener('click', () => {
                const symbol = el.dataset.symbol;
                this.insertElement(symbol);
            });
        });
    }
    
    insertElement(symbol) {
        const input = document.querySelector('input[name="equation"]:focus');
        if (input) {
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const text = input.value;
            
            input.value = text.substring(0, start) + symbol + text.substring(end);
            input.selectionStart = input.selectionEnd = start + symbol.length;
            input.focus();
            
            this.showToast(`Inserted ${symbol}`);
        }
    }
    
    async saveReaction() {
        const equation = document.querySelector('input[name="equation"]')?.value;
        if (!equation) {
            this.showToast('No equation to save', 'error');
            return;
        }
        
        try {
            const response = await fetch('/api/save_reaction', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ equation })
            });
            
            if (response.ok) {
                this.showToast('Reaction saved to database!');
                
                // Update UI
                this.updateSaveButton();
            }
        } catch (error) {
            console.error('Failed to save reaction:', error);
            this.showToast('Failed to save reaction', 'error');
        }
    }
    
    updateSaveButton() {
        const btn = document.getElementById('saveReactionBtn');
        if (btn) {
            btn.innerHTML = '<i class="fas fa-check"></i><span>Saved</span>';
            btn.classList.add('saved');
            
            setTimeout(() => {
                btn.innerHTML = '<i class="fas fa-bookmark"></i><span>Save Reaction</span>';
                btn.classList.remove('saved');
            }, 2000);
        }
    }
    
    updateOnlineStatus() {
        const status = navigator.onLine ? 'online' : 'offline';
        const statusElement = document.querySelector('.status');
        
        if (statusElement) {
            const icon = statusElement.querySelector('i');
            const text = statusElement.querySelector('span');
            
            if (status === 'online') {
                icon.className = 'fas fa-circle online';
                text.textContent = 'Online';
                this.showToast('Back online', 'success');
            } else {
                icon.className = 'fas fa-circle offline';
                text.textContent = 'Offline';
                this.showToast('Working offline', 'warning');
            }
        }
    }
    
    handleBeforeUnload(e) {
        // Check for unsaved data
        const hasUnsavedChanges = this.hasUnsavedChanges();
        
        if (hasUnsavedChanges) {
            e.preventDefault();
            e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
            return e.returnValue;
        }
    }
    
    hasUnsavedChanges() {
        // Implement logic to check for unsaved data
        return false;
    }
    
    loadSavedData() {
        // Load saved reactions from localStorage
        const saved = localStorage.getItem('zamanichem_saved_reactions');
        if (saved) {
            try {
                const reactions = JSON.parse(saved);
                this.renderSavedReactions(reactions);
            } catch (e) {
                console.error('Failed to load saved reactions:', e);
            }
        }
    }
    
    renderSavedReactions(reactions) {
        // Render saved reactions in sidebar
        const container = document.querySelector('.saved-reactions');
        if (container && reactions.length > 0) {
            let html = '<h4>Saved Reactions</h4>';
            reactions.forEach(reaction => {
                html += `<div class="saved-reaction">${reaction}</div>`;
            });
            container.innerHTML = html;
        }
    }
    
    async setupServiceWorker() {
        if ('serviceWorker' in navigator) {
            try {
                await navigator.serviceWorker.register('/sw.js');
                console.log('Service Worker registered');
            } catch (error) {
                console.error('Service Worker registration failed:', error);
            }
        }
    }
    
    showToast(message, type = 'info') {
        const toast = document.getElementById('toast');
        if (!toast) return;
        
        // Remove existing classes
        toast.className = 'toast';
        
        // Add type class
        toast.classList.add(type);
        
        // Set message
        toast.textContent = message;
        toast.classList.add('show');
        
        // Auto-hide
        setTimeout(() => {
            toast.classList.remove('show');
        }, 3000);
    }
    
    // Advanced calculations
    async calculateReactionProperties(equation) {
        try {
            const response = await fetch('/api/calculate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ equation })
            });
            
            if (response.ok) {
                return await response.json();
            }
        } catch (error) {
            console.error('Calculation failed:', error);
            return null;
        }
    }
    
    // Export functionality
    exportResults(format = 'pdf') {
        const results = document.querySelector('.results-container');
        if (!results) {
            this.showToast('No results to export', 'error');
            return;
        }
        
        switch (format) {
            case 'pdf':
                this.exportAsPDF(results);
                break;
            case 'image':
                this.exportAsImage(results);
                break;
            case 'text':
                this.exportAsText(results);
                break;
        }
    }
    
    exportAsPDF(element) {
        this.showToast('PDF export coming soon!', 'info');
        // Implement using jsPDF
    }
    
    exportAsImage(element) {
        html2canvas(element).then(canvas => {
            const link = document.createElement('a');
            link.download = 'reaction-results.png';
            link.href = canvas.toDataURL();
            link.click();
            this.showToast('Image downloaded!');
        });
    }
    
    exportAsText(element) {
        const text = element.innerText;
        const blob = new Blob([text], { type: 'text/plain' });
        const link = document.createElement('a');
        link.download = 'reaction-results.txt';
        link.href = URL.createObjectURL(blob);
        link.click();
        this.showToast('Text file downloaded!');
    }
    
    // Voice input (experimental)
    setupVoiceInput() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            
            const voiceBtn = document.createElement('button');
            voiceBtn.className = 'btn-icon voice-input';
            voiceBtn.innerHTML = '<i class="fas fa-microphone"></i>';
            voiceBtn.title = 'Voice Input';
            
            voiceBtn.addEventListener('click', () => {
                recognition.start();
                voiceBtn.classList.add('listening');
            });
            
            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                const input = document.querySelector('input[name="equation"]');
                if (input) {
                    input.value = transcript;
                    input.focus();
                }
                voiceBtn.classList.remove('listening');
                this.showToast('Voice input received');
            };
            
            recognition.onerror = () => {
                voiceBtn.classList.remove('listening');
                this.showToast('Voice input failed', 'error');
            };
            
            // Add to input group
            const inputGroup = document.querySelector('.input-with-buttons');
            if (inputGroup) {
                inputGroup.querySelector('.input-buttons').appendChild(voiceBtn);
            }
        }
    }
    
    // Real-time validation
    validateEquation(equation) {
        const errors = [];
        
        if (!equation.includes('->') && !equation.includes('=')) {
            errors.push('Equation must contain -> or =');
        }
        
        if (!equation.match(/[A-Z]/)) {
            errors.push('Equation must contain chemical symbols');
        }
        
        // Check for valid chemical symbols
        const symbols = equation.match(/[A-Z][a-z]*/g) || [];
        const validSymbols = ['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'K', 'Ca', 'Fe', 'Cu', 'Zn', 'Ag', 'Ba', 'Pb'];
        
        symbols.forEach(symbol => {
            if (!validSymbols.includes(symbol)) {
                errors.push(`Unknown element: ${symbol}`);
            }
        });
        
        return {
            valid: errors.length === 0,
            errors
        };
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.zamaniChem = new ZamaniChem();
    
    // Add CSS for dynamic elements
    const style = document.createElement('style');
    style.textContent = `
        .periodic-table-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .periodic-table-modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--bg-primary);
            border-radius: var(--border-radius-lg);
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }
        
        .element {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .element:hover {
            transform: scale(1.1);
            box-shadow: var(--shadow);
        }
        
        .voice-input.listening {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { background: var(--bg-tertiary); }
            50% { background: var(--primary); color: white; }
        }
        
        .toast.info { border-left-color: var(--info); }
        .toast.success { border-left-color: var(--success); }
        .toast.warning { border-left-color: var(--warning); }
        .toast.error { border-left-color: var(--danger); }
        
        .mobile .sidebar ~ .main-content {
            padding-top: 60px;
        }
    `;
    document.head.appendChild(style);
});

// Utility functions
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function throttle(func, limit) {
    let inThrottle;
    return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// PWA manifest
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').then(registration => {
            console.log('SW registered: ', registration);
        }).catch(registrationError => {
            console.log('SW registration failed: ', registrationError);
        });
    });
}

// Install prompt for PWA
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    
    // Show install button
    const installBtn = document.createElement('button');
    installBtn.className = 'install-btn';
    installBtn.innerHTML = '<i class="fas fa-download"></i> Install App';
    installBtn.addEventListener('click', async () => {
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        if (outcome === 'accepted') {
            console.log('User accepted install');
        }
        deferredPrompt = null;
        installBtn.remove();
    });
    
    // Add to page
    document.querySelector('.nav-footer')?.appendChild(installBtn);
});

// Export functionality
function exportResults(format) {
    const results = document.querySelector('.results-container');
    if (!results) {
        showToast('No results to export', 'error');
        return;
    }
    
    const data = {
        calculation: document.querySelector('.result-header h3')?.textContent || 'Chemistry Calculation',
        formula: document.querySelector('.formula-display')?.textContent || '',
        timestamp: new Date().toISOString()
    };
    
    // Collect result values
    document.querySelectorAll('.result-value').forEach(el => {
        const label = el.parentElement.querySelector('.result-label')?.textContent;
        const value = el.textContent;
        const unit = el.parentElement.querySelector('.unit')?.textContent;
        if (label && value) {
            const key = label.toLowerCase().replace(/\s+/g, '_');
            data[key] = value;
        }
    });
    
    switch(format) {
        case 'pdf':
            exportAsPDF(data);
            break;
        case 'json':
            exportAsJSON(data);
            break;
        case 'text':
            exportAsText(data);
            break;
    }
}

async function exportAsPDF(data) {
    try {
        const response = await fetch('/export/pdf', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data)
        });
        
        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'chemistry_report.pdf';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            showToast('PDF exported successfully!');
        } else {
            throw new Error('Export failed');
        }
    } catch (error) {
        console.error('Export error:', error);
        showToast('Export failed', 'error');
    }
}

async function exportAsJSON(data) {
    try {
        const response = await fetch('/export/json', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data)
        });
        
        if (response.ok) {
            const jsonData = await response.json();
            const jsonStr = JSON.stringify(jsonData, null, 2);
            const blob = new Blob([jsonStr], {type: 'application/json'});
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'chemistry_data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            showToast('JSON exported successfully!');
        }
    } catch (error) {
        console.error('Export error:', error);
        showToast('Export failed', 'error');
    }
}

function exportAsText(data) {
    let text = '=== Chemistry Calculation Report ===\n\n';
    text += `Generated: ${new Date().toLocaleString()}\n\n`;
    
    if (data.calculation) text += `Calculation: ${data.calculation}\n`;
    if (data.formula) text += `Formula: ${data.formula}\n\n`;
    
    text += 'Results:\n';
    for (const [key, value] of Object.entries(data)) {
        if (!['calculation', 'formula', 'timestamp'].includes(key)) {
            const label = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            text += `  ${label}: ${value}\n`;
        }
    }
    
    const blob = new Blob([text], {type: 'text/plain'});
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'chemistry_report.txt';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    showToast('Text file exported!');
}

// Quiz timer
class QuizTimer {
    constructor(duration, onUpdate, onComplete) {
        this.duration = duration; // in seconds
        this.timeLeft = duration;
        this.onUpdate = onUpdate;
        this.onComplete = onComplete;
        this.interval = null;
        this.isRunning = false;
    }
    
    start() {
        if (this.isRunning) return;
        this.isRunning = true;
        this.interval = setInterval(() => {
            this.timeLeft--;
            if (this.onUpdate) {
                this.onUpdate(this.timeLeft);
            }
            if (this.timeLeft <= 0) {
                this.stop();
                if (this.onComplete) {
                    this.onComplete();
                }
            }
        }, 1000);
    }
    
    stop() {
        if (this.interval) {
            clearInterval(this.interval);
            this.interval = null;
        }
        this.isRunning = false;
    }
    
    getFormattedTime() {
        const minutes = Math.floor(this.timeLeft / 60);
        const seconds = this.timeLeft % 60;
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
}

// Solution calculator utilities
function calculateMolarity() {
    const moles = parseFloat(document.getElementById('moles').value) || 0;
    const liters = parseFloat(document.getElementById('liters').value) || 0;
    
    if (liters > 0) {
        const molarity = moles / liters;
        showResult('molarity', molarity.toFixed(4), 'M');
        
        // If mass is provided, calculate moles
        const mass = parseFloat(document.getElementById('mass').value);
        if (mass) {
            const formula = document.getElementById('formula').value;
            calculateMolesFromMass(mass, formula, liters);
        }
    }
}

async function calculateMolesFromMass(mass, formula, liters) {
    try {
        const response = await fetch('/api/calculate_mass', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({formula: formula, amount: 1})
        });
        
        const data = await response.json();
        if (data.molar_mass) {
            const moles = mass / data.molar_mass;
            const molarity = moles / liters;
            showResult('calculated_molarity', molarity.toFixed(4), 'M');
            showResult('moles', moles.toFixed(4), 'mol');
        }
    } catch (error) {
        console.error('Error calculating moles:', error);
    }
}

function showResult(id, value, unit) {
    let resultDiv = document.getElementById('result-' + id);
    if (!resultDiv) {
        resultDiv = document.createElement('div');
        resultDiv.id = 'result-' + id;
        resultDiv.className = 'result-item';
        document.querySelector('.results-container').appendChild(resultDiv);
    }
    resultDiv.innerHTML = `<strong>${id.replace('_', ' ').toUpperCase()}:</strong> ${value} ${unit}`;
}

// Mobile camera OCR (placeholder for future implementation)
function captureEquation() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showToast('Camera access not available', 'error');
        return;
    }
    
    showToast('Camera feature coming soon!', 'info');
    // Future implementation: Use Tesseract.js or other OCR library
}

// Add to your existing showToast function if not present
function showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.classList.add('show');
    }, 10);
    
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}